/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
export namespace Components {
    interface AAlert {
        /**
          * Set to true to make the alert closable.
         */
        "closable": boolean;
        /**
          * Hides the alert
         */
        "hide": () => Promise<void>;
        /**
          * Indicates whether or not the alert is open. You can use this in lieu of the show/hide methods.
         */
        "open": boolean;
        /**
          * Shows the alert.
         */
        "show": () => Promise<void>;
        /**
          * The type of alert.
         */
        "type": 'primary' | 'success' | 'info' | 'warning' | 'danger';
    }
    interface AAnimation {
        /**
          * Clears all KeyframeEffects caused by this animation and aborts its playback.
         */
        "cancel": () => Promise<void>;
        /**
          * The number of milliseconds to delay the start of the animation.
         */
        "delay": number;
        /**
          * Determines the direction of playback as well as the behavior when reaching the end of an iteration.
         */
        "direction": PlaybackDirection;
        /**
          * The number of milliseconds each iteration of the animation takes to complete.
         */
        "duration": number;
        /**
          * The rate of the animation's change over time.
         */
        "easing": string;
        /**
          * The number of milliseconds to delay after the active period of an animation sequence.
         */
        "endDelay": number;
        /**
          * Sets how the animation applies styles to its target before and after its execution.
         */
        "fill": FillMode;
        /**
          * Sets the playback time to the end of the animation corresponding to the current playback direction.
         */
        "finish": () => Promise<void>;
        /**
          * Gets a list of all supported animation names.
         */
        "getAnimationNames": () => Promise<void>;
        /**
          * Gets the current time of the animation in milliseconds.
         */
        "getCurrentTime": () => Promise<number>;
        /**
          * Gets a list of all supported easing function names.
         */
        "getEasingNames": () => Promise<void>;
        /**
          * The offset at which to start the animation, usually between 0 (start) and 1 (end).
         */
        "iterationStart": number;
        /**
          * The number of iterations to run before the animation completes. Defaults to `Infinity`, which loops.
         */
        "iterations": number;
        /**
          * The keyframes to use for the animation. If this is set, `name` will be ignored.
         */
        "keyframes": Keyframe[];
        /**
          * The name of the animation to use.
         */
        "name": string;
        /**
          * Pauses the animation. The animation will resume when this prop is removed.
         */
        "pause": boolean;
        /**
          * Sets the animation's playback rate. The default is `1`, which plays the animation at a normal speed. Setting this to `2`, for example, will double the animation's speed. A negative value can be used to reverse the animation. This value can be changed without causing the animation to restart.
         */
        "playbackRate": number;
        /**
          * Sets the current time of the animation in milliseconds.
         */
        "setCurrentTime": (time: number) => Promise<void>;
    }
    interface AAvatar {
        /**
          * Alternative text for the image.
         */
        "alt": string;
        /**
          * The image source to use for the avatar.
         */
        "image": string;
        /**
          * Initials to use as a fallback when no image is available (1-2 characters max recommended).
         */
        "initials": string;
        /**
          * The shape of the avatar.
         */
        "shape": 'circle' | 'square' | 'rounded';
    }
    interface ABadge {
        /**
          * Set to true to draw a pill-style badge with rounded edges.
         */
        "pill": boolean;
        /**
          * Set to true to make the badge pulsate to draw attention.
         */
        "pulse": boolean;
        /**
          * The badge's type.
         */
        "type": 'primary' | 'success' | 'info' | 'warning' | 'danger' | 'text';
    }
    interface AButton {
        /**
          * Set to true to draw the button with a caret for use with dropdowns, popovers, etc.
         */
        "caret": boolean;
        /**
          * Set to true to draw a circle button.
         */
        "circle": boolean;
        /**
          * Set to true to disable the button.
         */
        "disabled": boolean;
        /**
          * Tells the browser to download the linked file as this filename. Only used when `href` is set.
         */
        "download": string;
        /**
          * When set, the underlying button will be rendered as an `<a>` with this `href` instead of a `<button>`.
         */
        "href": string;
        /**
          * Set to true to draw the button in a loading state.
         */
        "loading": boolean;
        /**
          * An optional name for the button. Ignored when `href` is set.
         */
        "name": string;
        /**
          * Set to true to draw a pill-style button with rounded edges.
         */
        "pill": boolean;
        /**
          * Removes focus from the button.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the button.
         */
        "setFocus": () => Promise<void>;
        /**
          * The button's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Indicates if activating the button should submit the form. Ignored when `href` is set.
         */
        "submit": boolean;
        /**
          * Tells the browser where to open the link. Only used when `href` is set.
         */
        "target": '_blank' | '_parent' | '_self' | '_top';
        /**
          * The button's type.
         */
        "type": | 'default'
    | 'primary'
    | 'success'
    | 'info'
    | 'warning'
    | 'danger'
    | 'text';
        /**
          * An optional value for the button. Ignored when `href` is set.
         */
        "value": string;
    }
    interface AButtonGroup {
        /**
          * A label to use for the button groups `aria-label` attribute.
         */
        "label": string;
    }
    interface ACard {
    }
    interface ACheckbox {
        /**
          * Set to true to draw the checkbox in a checked state.
         */
        "checked": boolean;
        /**
          * Set to true to disable the checkbox.
         */
        "disabled": boolean;
        /**
          * Set to true to draw the checkbox in an indeterminate state.
         */
        "indeterminate": boolean;
        /**
          * The checkbox's name attribute.
         */
        "name": string;
        /**
          * Removes focus from the checkbox.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the checkbox.
         */
        "setFocus": () => Promise<void>;
        /**
          * The checkbox's value attribute.
         */
        "value": string;
    }
    interface ADetails {
        /**
          * Set to true to prevent the user from toggling the details.
         */
        "disabled": boolean;
        /**
          * Hides the alert
         */
        "hide": () => Promise<void>;
        /**
          * Indicates whether or not the details is open. You can use this in lieu of the show/hide methods.
         */
        "open": boolean;
        /**
          * Shows the alert.
         */
        "show": () => Promise<void>;
        /**
          * The summary to show in the details header. If you need to display HTML, use the `summary` slot instead.
         */
        "summary": string;
    }
    interface ADialog {
        /**
          * Hides the dialog
         */
        "hide": () => Promise<void>;
        /**
          * The dialog's label as displayed in the header. You should always include a relevant label even when using `no-header`, as it is required for proper accessibility.
         */
        "label": string;
        /**
          * Set to true to disable the header. This will also remove the default close button, so please ensure you provide an easy, accessible way for users to dismiss the dialog.
         */
        "noHeader": boolean;
        /**
          * Indicates whether or not the dialog is open. You can use this in lieu of the show/hide methods.
         */
        "open": boolean;
        /**
          * Shows the dialog
         */
        "show": () => Promise<void>;
    }
    interface ADrawer {
        /**
          * By default, the drawer slides out of its containing block (usually the viewport). To make the drawer slide out of its parent element, set this prop and add `position: relative` to the parent.
         */
        "contained": boolean;
        /**
          * Hides the drawer
         */
        "hide": () => Promise<void>;
        /**
          * The drawer's label as displayed in the header. You should always include a relevant label even when using `no-header`, as it is required for proper accessibility.
         */
        "label": string;
        /**
          * Removes the header. This will also remove the default close button, so please ensure you provide an easy, accessible way for users to dismiss the drawer.
         */
        "noHeader": boolean;
        /**
          * Indicates whether or not the drawer is open. You can use this in lieu of the show/hide methods.
         */
        "open": boolean;
        /**
          * The direction from which the drawer will open.
         */
        "placement": 'top' | 'right' | 'bottom' | 'left';
        /**
          * Shows the drawer
         */
        "show": () => Promise<void>;
    }
    interface ADropdown {
        /**
          * Determines whether the dropdown should hide when a menu item is selected.
         */
        "closeOnSelect": boolean;
        /**
          * The dropdown will close when the user interacts outside of this element (e.g. clicking).
         */
        "containingElement": HTMLElement;
        /**
          * The distance in pixels from which to offset the panel away from its trigger.
         */
        "distance": number;
        /**
          * Hides the dropdown panel
         */
        "hide": () => Promise<void>;
        /**
          * Indicates whether or not the dropdown is open. You can use this in lieu of the show/hide methods.
         */
        "open": boolean;
        /**
          * The preferred placement of the dropdown panel. Note that the actual placement may vary as needed to keep the panel inside of the viewport.
         */
        "placement": | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'left'
    | 'left-start'
    | 'left-end';
        /**
          * Shows the dropdown panel
         */
        "show": () => Promise<void>;
        /**
          * The distance in pixels from which to offset the panel along its trigger.
         */
        "skidding": number;
    }
    interface AForm {
        /**
          * The first name
         */
        "first": string;
        /**
          * The last name
         */
        "last": string;
        /**
          * The middle name
         */
        "middle": string;
    }
    interface AIcon {
        /**
          * An alternative description to use for accessibility. If omitted, the name or src will be used to generate it.
         */
        "label": string;
        /**
          * The name of the icon to draw.
         */
        "name": string;
        /**
          * An external URL of an SVG file.
         */
        "src": string;
    }
    interface AIconButton {
        /**
          * Set to true to disable the button.
         */
        "disabled": boolean;
        /**
          * An alternative description to use for accessibility. If omitted, the name or src will be used to generate it.
         */
        "label": string;
        /**
          * The name of the icon to draw. See the icon component for a full list of icons.
         */
        "name": string;
        /**
          * An external URL of an SVG file.
         */
        "src": string;
    }
    interface AInput {
        /**
          * The input's autocaptialize attribute.
         */
        "autocapitalize": string;
        /**
          * The input's autocomplete attribute.
         */
        "autocomplete": string;
        /**
          * The input's autocorrect attribute.
         */
        "autocorrect": string;
        /**
          * The input's autofocus attribute.
         */
        "autofocus": boolean;
        /**
          * Set to true to add a clear button when the input is populated.
         */
        "clearable": boolean;
        /**
          * Set to true to disable the input.
         */
        "disabled": boolean;
        /**
          * The input's inputmode attribute.
         */
        "inputmode": | 'none'
    | 'text'
    | 'decimal'
    | 'numeric'
    | 'tel'
    | 'search'
    | 'email'
    | 'url';
        /**
          * Set to true to indicate that the user input is invalid.
         */
        "invalid": boolean;
        /**
          * The input's label.
         */
        "label": string;
        /**
          * The input's max attribute.
         */
        "max": number;
        /**
          * The input's maxlength attribute.
         */
        "maxlength": number;
        /**
          * The input's min attribute.
         */
        "min": number;
        /**
          * The input's minlength attribute.
         */
        "minlength": number;
        /**
          * The input's name attribute.
         */
        "name": string;
        /**
          * The input's pattern attribute.
         */
        "pattern": string;
        /**
          * Set to true to draw a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * Set to true for a readonly input.
         */
        "readonly": boolean;
        /**
          * Removes focus from the input.
         */
        "removeFocus": () => Promise<void>;
        /**
          * The input's required attribute.
         */
        "required": boolean;
        /**
          * Selects all the text in the input.
         */
        "select": () => Promise<void>;
        /**
          * Sets focus on the input.
         */
        "setFocus": () => Promise<void>;
        /**
          * Replaces a range of text with a new string.
         */
        "setRangeText": (replacement: string, start: number, end: number, selectMode?: 'select' | 'start' | 'end' | 'preserve') => Promise<void>;
        /**
          * Sets the start and end positions of the text selection (0-based).
         */
        "setSelectionRange": (selectionStart: number, selectionEnd: number, selectionDirection?: 'forward' | 'backward' | 'none') => Promise<void>;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The input's step attribute.
         */
        "step": number;
        /**
          * Set to true to add a password toggle button for password inputs.
         */
        "togglePassword": boolean;
        /**
          * The input's type.
         */
        "type": | 'email'
    | 'number'
    | 'password'
    | 'search'
    | 'tel'
    | 'text'
    | 'url';
        /**
          * Set to true to indicate that the user input is valid.
         */
        "valid": boolean;
        /**
          * The input's value attribute.
         */
        "value": string;
    }
    interface AMenu {
        /**
          * Removes focus from the menu.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the menu.
         */
        "setFocus": () => Promise<void>;
        /**
          * Initiates type-to-select logic, which automatically selects an option based on what the user is currently typing. The key passed will be appended to the internal query and the selection will be updated. After a brief period, the internal query is cleared automatically. This method is intended to be used with the keydown event. Useful for enabling type-to-select when the menu doesn't have focus.
         */
        "typeToSelect": (key: string) => Promise<void>;
    }
    interface AMenuDivider {
    }
    interface AMenuItem {
        /**
          * Set to true to draw the menu item in an active state.
         */
        "active": boolean;
        /**
          * Set to true to draw the item in a checked state.
         */
        "checked": boolean;
        /**
          * Set to true to draw the menu item in a disabled state.
         */
        "disabled": boolean;
        /**
          * A unique value to store in the menu item.
         */
        "value": string;
    }
    interface AMenuLabel {
    }
    interface AProgressBar {
        /**
          * The progress bar's percentage, 0 to 100.
         */
        "percentage": number;
    }
    interface AProgressRing {
        /**
          * The current progress percentage, 0 - 100.
         */
        "percentage": number;
        /**
          * The size of the progress ring in pixels.
         */
        "size": number;
        /**
          * The stroke width of the progress ring in pixels.
         */
        "strokeWidth": number;
    }
    interface ARadio {
        /**
          * Set to true to draw the radio in a checked state.
         */
        "checked": boolean;
        /**
          * Set to true to disable the radio.
         */
        "disabled": boolean;
        /**
          * The radio's name attribute.
         */
        "name": string;
        /**
          * Removes focus from the radio.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the radio.
         */
        "setFocus": () => Promise<void>;
        /**
          * The radio's value attribute.
         */
        "value": string;
    }
    interface ARange {
        /**
          * Set to true to disable the input.
         */
        "disabled": boolean;
        /**
          * The input's max attribute.
         */
        "max": number;
        /**
          * The input's min attribute.
         */
        "min": number;
        /**
          * The input's name attribute.
         */
        "name": string;
        /**
          * Removes focus from the input.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the input.
         */
        "setFocus": () => Promise<void>;
        /**
          * The input's step attribute.
         */
        "step": number;
        /**
          * The preferred placedment of the tooltip.
         */
        "tooltip": 'top' | 'bottom' | 'none';
        /**
          * A function used to format the tooltip's value.
         */
        "tooltipFormatter": (value: number) => string;
        /**
          * The input's value attribute.
         */
        "value": number;
    }
    interface ARating {
        /**
          * Disables the rating.
         */
        "disabled": boolean;
        /**
          * A function that returns the symbols to display. Accepts an option `value` parameter you can use to map a specific symbol to a value.
         */
        "getSymbol": (value?: number) => string;
        /**
          * The highest rating to show.
         */
        "max": number;
        /**
          * The minimum increment value allowed by the control.
         */
        "precision": number;
        /**
          * Makes the rating readonly.
         */
        "readonly": boolean;
        /**
          * Removes focus from the rating.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the rating.
         */
        "setFocus": () => Promise<void>;
        /**
          * The current rating.
         */
        "value": number;
    }
    interface ASelect {
        /**
          * Set to true to disable the select control.
         */
        "disabled": boolean;
        /**
          * Set to true to indicate that the user input is invalid.
         */
        "invalid": boolean;
        /**
          * The select's label.
         */
        "label": string;
        /**
          * The maximum number of tags to show when `multiple` is true. After the maximum, "+n" will be shown to indicate the number of additional items that are selected. Set to -1 to remove the limit.
         */
        "maxTagsVisible": number;
        /**
          * Set to true to enable multiselect.
         */
        "multiple": boolean;
        /**
          * The select's name.
         */
        "name": string;
        /**
          * Set to true to draw a pill-style select with rounded edges.
         */
        "pill": boolean;
        /**
          * The select's placeholder text.
         */
        "placeholder": string;
        /**
          * The select's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Set to true to indicate that the user input is valid.
         */
        "valid": boolean;
        /**
          * The value of the control. This will be a string or an array depending on `multiple`.
         */
        "value": string | Array<string>;
    }
    interface ASkeleton {
        /**
          * Determines which effect the skeleton will use.
         */
        "effect": 'pulse' | 'sheen' | 'none';
    }
    interface ASpinner {
    }
    interface ASwitch {
        /**
          * Set to true to draw the switch in a checked state.
         */
        "checked": boolean;
        /**
          * Set to true to disable the switch.
         */
        "disabled": boolean;
        /**
          * The switch's name attribute.
         */
        "name": string;
        /**
          * Removes focus from the switch.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the switch.
         */
        "setFocus": () => Promise<void>;
        /**
          * The switch's value attribute.
         */
        "value": string;
    }
    interface ATab {
        /**
          * Set to true to draw the tab in an active state.
         */
        "active": boolean;
        /**
          * Set to true to draw the tab in a disabled state.
         */
        "disabled": boolean;
        /**
          * The name of the tab panel the tab will control. The panel must be located in the same tab group.
         */
        "panel": string;
        /**
          * Removes focus from the tab.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus to the tab.
         */
        "setFocus": () => Promise<void>;
    }
    interface ATabGroup {
        /**
          * The placement of the tabs.
         */
        "placement": 'top' | 'bottom' | 'left' | 'right';
        /**
          * Shows the specified tab panel.
         */
        "show": (panel: string) => Promise<void>;
    }
    interface ATabPanel {
        /**
          * When true, the tab panel will be shown.
         */
        "active": boolean;
        /**
          * The tab panel's name.
         */
        "name": string;
    }
    interface ATag {
        /**
          * Set to true to make the tag clearable.
         */
        "clearable": boolean;
        /**
          * Set to true to draw a pill-style tag with rounded edges.
         */
        "pill": boolean;
        /**
          * The tag's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The tag's type.
         */
        "type": | 'primary'
    | 'success'
    | 'info'
    | 'warning'
    | 'danger'
    | 'text';
    }
    interface ATextarea {
        /**
          * The textarea's autocaptialize attribute.
         */
        "autocapitalize": string;
        /**
          * The textarea's autocomplete attribute.
         */
        "autocomplete": string;
        /**
          * The textarea's autocorrect attribute.
         */
        "autocorrect": string;
        /**
          * The textarea's autofocus attribute.
         */
        "autofocus": boolean;
        /**
          * Set to true to disable the textarea.
         */
        "disabled": boolean;
        /**
          * The textarea's inputmode attribute.
         */
        "inputmode": | 'none'
    | 'text'
    | 'decimal'
    | 'numeric'
    | 'tel'
    | 'search'
    | 'email'
    | 'url';
        /**
          * Set to true to indicate that the user input is invalid.
         */
        "invalid": boolean;
        /**
          * The textarea's label.
         */
        "label": string;
        /**
          * The textarea's maxlength attribute.
         */
        "maxlength": number;
        /**
          * The textarea's name attribute.
         */
        "name": string;
        /**
          * The textarea's placeholder text.
         */
        "placeholder": string;
        /**
          * Set to true for a readonly textarea.
         */
        "readonly": boolean;
        /**
          * Removes focus fromt the textarea.
         */
        "removeFocus": () => Promise<void>;
        /**
          * The textarea's required attribute.
         */
        "required": boolean;
        /**
          * Controls how the textarea can be resized.
         */
        "resize": 'none' | 'vertical' | 'auto';
        /**
          * The number of rows to display by default.
         */
        "rows": number;
        /**
          * Selects all the text in the input.
         */
        "select": () => Promise<void>;
        /**
          * Sets focus on the textarea.
         */
        "setFocus": () => Promise<void>;
        /**
          * Replaces a range of text with a new string.
         */
        "setRangeText": (replacement: string, start: number, end: number, selectMode?: 'select' | 'start' | 'end' | 'preserve') => Promise<void>;
        /**
          * Sets the start and end positions of the text selection (0-based).
         */
        "setSelectionRange": (selectionStart: number, selectionEnd: number, selectionDirection?: 'forward' | 'backward' | 'none') => Promise<void>;
        /**
          * The textarea's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Set to true to indicate that the user input is valid.
         */
        "valid": boolean;
        /**
          * The textarea's value attribute.
         */
        "value": string;
    }
    interface ATooltip {
        /**
          * The tooltip's content.
         */
        "content": string;
        /**
          * Set to true to disable the tooltip so it won't show when triggered.
         */
        "disabled": boolean;
        /**
          * The distance in pixels from which to offset the tooltip away from its target.
         */
        "distance": number;
        /**
          * Shows the tooltip.
         */
        "hide": () => Promise<void>;
        /**
          * Indicates whether or not the tooltip is open. You can use this in lieu of the show/hide methods.
         */
        "open": boolean;
        /**
          * The preferred placement of the tooltip. Note that the actual placement may vary as needed to keep the tooltip inside of the viewport.
         */
        "placement": | 'top'
    | 'top-start'
    | 'top-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'left'
    | 'left-start'
    | 'left-end';
        /**
          * Shows the tooltip.
         */
        "show": () => Promise<void>;
        /**
          * The distance in pixels from which to offset the tooltip along its target.
         */
        "skidding": number;
        /**
          * Controls how the tooltip is activated. Possible options include `click`, `hover`, `focus`, and `manual`. Multiple options can be passed by separating them with a space. When manual is used, the tooltip must be activated programmatically.
         */
        "trigger": string;
    }
}
declare global {
    interface HTMLAAlertElement extends Components.AAlert, HTMLStencilElement {
    }
    var HTMLAAlertElement: {
        prototype: HTMLAAlertElement;
        new (): HTMLAAlertElement;
    };
    interface HTMLAAnimationElement extends Components.AAnimation, HTMLStencilElement {
    }
    var HTMLAAnimationElement: {
        prototype: HTMLAAnimationElement;
        new (): HTMLAAnimationElement;
    };
    interface HTMLAAvatarElement extends Components.AAvatar, HTMLStencilElement {
    }
    var HTMLAAvatarElement: {
        prototype: HTMLAAvatarElement;
        new (): HTMLAAvatarElement;
    };
    interface HTMLABadgeElement extends Components.ABadge, HTMLStencilElement {
    }
    var HTMLABadgeElement: {
        prototype: HTMLABadgeElement;
        new (): HTMLABadgeElement;
    };
    interface HTMLAButtonElement extends Components.AButton, HTMLStencilElement {
    }
    var HTMLAButtonElement: {
        prototype: HTMLAButtonElement;
        new (): HTMLAButtonElement;
    };
    interface HTMLAButtonGroupElement extends Components.AButtonGroup, HTMLStencilElement {
    }
    var HTMLAButtonGroupElement: {
        prototype: HTMLAButtonGroupElement;
        new (): HTMLAButtonGroupElement;
    };
    interface HTMLACardElement extends Components.ACard, HTMLStencilElement {
    }
    var HTMLACardElement: {
        prototype: HTMLACardElement;
        new (): HTMLACardElement;
    };
    interface HTMLACheckboxElement extends Components.ACheckbox, HTMLStencilElement {
    }
    var HTMLACheckboxElement: {
        prototype: HTMLACheckboxElement;
        new (): HTMLACheckboxElement;
    };
    interface HTMLADetailsElement extends Components.ADetails, HTMLStencilElement {
    }
    var HTMLADetailsElement: {
        prototype: HTMLADetailsElement;
        new (): HTMLADetailsElement;
    };
    interface HTMLADialogElement extends Components.ADialog, HTMLStencilElement {
    }
    var HTMLADialogElement: {
        prototype: HTMLADialogElement;
        new (): HTMLADialogElement;
    };
    interface HTMLADrawerElement extends Components.ADrawer, HTMLStencilElement {
    }
    var HTMLADrawerElement: {
        prototype: HTMLADrawerElement;
        new (): HTMLADrawerElement;
    };
    interface HTMLADropdownElement extends Components.ADropdown, HTMLStencilElement {
    }
    var HTMLADropdownElement: {
        prototype: HTMLADropdownElement;
        new (): HTMLADropdownElement;
    };
    interface HTMLAFormElement extends Components.AForm, HTMLStencilElement {
    }
    var HTMLAFormElement: {
        prototype: HTMLAFormElement;
        new (): HTMLAFormElement;
    };
    interface HTMLAIconElement extends Components.AIcon, HTMLStencilElement {
    }
    var HTMLAIconElement: {
        prototype: HTMLAIconElement;
        new (): HTMLAIconElement;
    };
    interface HTMLAIconButtonElement extends Components.AIconButton, HTMLStencilElement {
    }
    var HTMLAIconButtonElement: {
        prototype: HTMLAIconButtonElement;
        new (): HTMLAIconButtonElement;
    };
    interface HTMLAInputElement extends Components.AInput, HTMLStencilElement {
    }
    var HTMLAInputElement: {
        prototype: HTMLAInputElement;
        new (): HTMLAInputElement;
    };
    interface HTMLAMenuElement extends Components.AMenu, HTMLStencilElement {
    }
    var HTMLAMenuElement: {
        prototype: HTMLAMenuElement;
        new (): HTMLAMenuElement;
    };
    interface HTMLAMenuDividerElement extends Components.AMenuDivider, HTMLStencilElement {
    }
    var HTMLAMenuDividerElement: {
        prototype: HTMLAMenuDividerElement;
        new (): HTMLAMenuDividerElement;
    };
    interface HTMLAMenuItemElement extends Components.AMenuItem, HTMLStencilElement {
    }
    var HTMLAMenuItemElement: {
        prototype: HTMLAMenuItemElement;
        new (): HTMLAMenuItemElement;
    };
    interface HTMLAMenuLabelElement extends Components.AMenuLabel, HTMLStencilElement {
    }
    var HTMLAMenuLabelElement: {
        prototype: HTMLAMenuLabelElement;
        new (): HTMLAMenuLabelElement;
    };
    interface HTMLAProgressBarElement extends Components.AProgressBar, HTMLStencilElement {
    }
    var HTMLAProgressBarElement: {
        prototype: HTMLAProgressBarElement;
        new (): HTMLAProgressBarElement;
    };
    interface HTMLAProgressRingElement extends Components.AProgressRing, HTMLStencilElement {
    }
    var HTMLAProgressRingElement: {
        prototype: HTMLAProgressRingElement;
        new (): HTMLAProgressRingElement;
    };
    interface HTMLARadioElement extends Components.ARadio, HTMLStencilElement {
    }
    var HTMLARadioElement: {
        prototype: HTMLARadioElement;
        new (): HTMLARadioElement;
    };
    interface HTMLARangeElement extends Components.ARange, HTMLStencilElement {
    }
    var HTMLARangeElement: {
        prototype: HTMLARangeElement;
        new (): HTMLARangeElement;
    };
    interface HTMLARatingElement extends Components.ARating, HTMLStencilElement {
    }
    var HTMLARatingElement: {
        prototype: HTMLARatingElement;
        new (): HTMLARatingElement;
    };
    interface HTMLASelectElement extends Components.ASelect, HTMLStencilElement {
    }
    var HTMLASelectElement: {
        prototype: HTMLASelectElement;
        new (): HTMLASelectElement;
    };
    interface HTMLASkeletonElement extends Components.ASkeleton, HTMLStencilElement {
    }
    var HTMLASkeletonElement: {
        prototype: HTMLASkeletonElement;
        new (): HTMLASkeletonElement;
    };
    interface HTMLASpinnerElement extends Components.ASpinner, HTMLStencilElement {
    }
    var HTMLASpinnerElement: {
        prototype: HTMLASpinnerElement;
        new (): HTMLASpinnerElement;
    };
    interface HTMLASwitchElement extends Components.ASwitch, HTMLStencilElement {
    }
    var HTMLASwitchElement: {
        prototype: HTMLASwitchElement;
        new (): HTMLASwitchElement;
    };
    interface HTMLATabElement extends Components.ATab, HTMLStencilElement {
    }
    var HTMLATabElement: {
        prototype: HTMLATabElement;
        new (): HTMLATabElement;
    };
    interface HTMLATabGroupElement extends Components.ATabGroup, HTMLStencilElement {
    }
    var HTMLATabGroupElement: {
        prototype: HTMLATabGroupElement;
        new (): HTMLATabGroupElement;
    };
    interface HTMLATabPanelElement extends Components.ATabPanel, HTMLStencilElement {
    }
    var HTMLATabPanelElement: {
        prototype: HTMLATabPanelElement;
        new (): HTMLATabPanelElement;
    };
    interface HTMLATagElement extends Components.ATag, HTMLStencilElement {
    }
    var HTMLATagElement: {
        prototype: HTMLATagElement;
        new (): HTMLATagElement;
    };
    interface HTMLATextareaElement extends Components.ATextarea, HTMLStencilElement {
    }
    var HTMLATextareaElement: {
        prototype: HTMLATextareaElement;
        new (): HTMLATextareaElement;
    };
    interface HTMLATooltipElement extends Components.ATooltip, HTMLStencilElement {
    }
    var HTMLATooltipElement: {
        prototype: HTMLATooltipElement;
        new (): HTMLATooltipElement;
    };
    interface HTMLElementTagNameMap {
        "a-alert": HTMLAAlertElement;
        "a-animation": HTMLAAnimationElement;
        "a-avatar": HTMLAAvatarElement;
        "a-badge": HTMLABadgeElement;
        "a-button": HTMLAButtonElement;
        "a-button-group": HTMLAButtonGroupElement;
        "a-card": HTMLACardElement;
        "a-checkbox": HTMLACheckboxElement;
        "a-details": HTMLADetailsElement;
        "a-dialog": HTMLADialogElement;
        "a-drawer": HTMLADrawerElement;
        "a-dropdown": HTMLADropdownElement;
        "a-form": HTMLAFormElement;
        "a-icon": HTMLAIconElement;
        "a-icon-button": HTMLAIconButtonElement;
        "a-input": HTMLAInputElement;
        "a-menu": HTMLAMenuElement;
        "a-menu-divider": HTMLAMenuDividerElement;
        "a-menu-item": HTMLAMenuItemElement;
        "a-menu-label": HTMLAMenuLabelElement;
        "a-progress-bar": HTMLAProgressBarElement;
        "a-progress-ring": HTMLAProgressRingElement;
        "a-radio": HTMLARadioElement;
        "a-range": HTMLARangeElement;
        "a-rating": HTMLARatingElement;
        "a-select": HTMLASelectElement;
        "a-skeleton": HTMLASkeletonElement;
        "a-spinner": HTMLASpinnerElement;
        "a-switch": HTMLASwitchElement;
        "a-tab": HTMLATabElement;
        "a-tab-group": HTMLATabGroupElement;
        "a-tab-panel": HTMLATabPanelElement;
        "a-tag": HTMLATagElement;
        "a-textarea": HTMLATextareaElement;
        "a-tooltip": HTMLATooltipElement;
    }
}
declare namespace LocalJSX {
    interface AAlert {
        /**
          * Set to true to make the alert closable.
         */
        "closable"?: boolean;
        /**
          * Emitted after the alert closes and all transitions are complete.
         */
        "onSlAfterHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted after the alert opens and all transitions are complete.
         */
        "onSlAfterShow"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the alert closes. Calling `event.preventDefault()` will prevent it from being closed.
         */
        "onSlHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the alert opens. Calling `event.preventDefault()` will prevent it from being opened.
         */
        "onSlShow"?: (event: CustomEvent<any>) => void;
        /**
          * Indicates whether or not the alert is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
        /**
          * The type of alert.
         */
        "type"?: 'primary' | 'success' | 'info' | 'warning' | 'danger';
    }
    interface AAnimation {
        /**
          * The number of milliseconds to delay the start of the animation.
         */
        "delay"?: number;
        /**
          * Determines the direction of playback as well as the behavior when reaching the end of an iteration.
         */
        "direction"?: PlaybackDirection;
        /**
          * The number of milliseconds each iteration of the animation takes to complete.
         */
        "duration"?: number;
        /**
          * The rate of the animation's change over time.
         */
        "easing"?: string;
        /**
          * The number of milliseconds to delay after the active period of an animation sequence.
         */
        "endDelay"?: number;
        /**
          * Sets how the animation applies styles to its target before and after its execution.
         */
        "fill"?: FillMode;
        /**
          * The offset at which to start the animation, usually between 0 (start) and 1 (end).
         */
        "iterationStart"?: number;
        /**
          * The number of iterations to run before the animation completes. Defaults to `Infinity`, which loops.
         */
        "iterations"?: number;
        /**
          * The keyframes to use for the animation. If this is set, `name` will be ignored.
         */
        "keyframes"?: Keyframe[];
        /**
          * The name of the animation to use.
         */
        "name"?: string;
        /**
          * Emitted when the animation is canceled.
         */
        "onACancel"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the animation finishes.
         */
        "onAFinish"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the animation starts or restarts.
         */
        "onAStart"?: (event: CustomEvent<any>) => void;
        /**
          * Pauses the animation. The animation will resume when this prop is removed.
         */
        "pause"?: boolean;
        /**
          * Sets the animation's playback rate. The default is `1`, which plays the animation at a normal speed. Setting this to `2`, for example, will double the animation's speed. A negative value can be used to reverse the animation. This value can be changed without causing the animation to restart.
         */
        "playbackRate"?: number;
    }
    interface AAvatar {
        /**
          * Alternative text for the image.
         */
        "alt"?: string;
        /**
          * The image source to use for the avatar.
         */
        "image"?: string;
        /**
          * Initials to use as a fallback when no image is available (1-2 characters max recommended).
         */
        "initials"?: string;
        /**
          * The shape of the avatar.
         */
        "shape"?: 'circle' | 'square' | 'rounded';
    }
    interface ABadge {
        /**
          * Set to true to draw a pill-style badge with rounded edges.
         */
        "pill"?: boolean;
        /**
          * Set to true to make the badge pulsate to draw attention.
         */
        "pulse"?: boolean;
        /**
          * The badge's type.
         */
        "type"?: 'primary' | 'success' | 'info' | 'warning' | 'danger' | 'text';
    }
    interface AButton {
        /**
          * Set to true to draw the button with a caret for use with dropdowns, popovers, etc.
         */
        "caret"?: boolean;
        /**
          * Set to true to draw a circle button.
         */
        "circle"?: boolean;
        /**
          * Set to true to disable the button.
         */
        "disabled"?: boolean;
        /**
          * Tells the browser to download the linked file as this filename. Only used when `href` is set.
         */
        "download"?: string;
        /**
          * When set, the underlying button will be rendered as an `<a>` with this `href` instead of a `<button>`.
         */
        "href"?: string;
        /**
          * Set to true to draw the button in a loading state.
         */
        "loading"?: boolean;
        /**
          * An optional name for the button. Ignored when `href` is set.
         */
        "name"?: string;
        /**
          * Emitted when the button loses focus.
         */
        "onSlBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the button gains focus.
         */
        "onSlFocus"?: (event: CustomEvent<any>) => void;
        /**
          * Set to true to draw a pill-style button with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The button's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Indicates if activating the button should submit the form. Ignored when `href` is set.
         */
        "submit"?: boolean;
        /**
          * Tells the browser where to open the link. Only used when `href` is set.
         */
        "target"?: '_blank' | '_parent' | '_self' | '_top';
        /**
          * The button's type.
         */
        "type"?: | 'default'
    | 'primary'
    | 'success'
    | 'info'
    | 'warning'
    | 'danger'
    | 'text';
        /**
          * An optional value for the button. Ignored when `href` is set.
         */
        "value"?: string;
    }
    interface AButtonGroup {
        /**
          * A label to use for the button groups `aria-label` attribute.
         */
        "label"?: string;
    }
    interface ACard {
    }
    interface ACheckbox {
        /**
          * Set to true to draw the checkbox in a checked state.
         */
        "checked"?: boolean;
        /**
          * Set to true to disable the checkbox.
         */
        "disabled"?: boolean;
        /**
          * Set to true to draw the checkbox in an indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * The checkbox's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onSlBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control's checked state changes.
         */
        "onSlChange"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onSlFocus"?: (event: CustomEvent<any>) => void;
        /**
          * The checkbox's value attribute.
         */
        "value"?: string;
    }
    interface ADetails {
        /**
          * Set to true to prevent the user from toggling the details.
         */
        "disabled"?: boolean;
        /**
          * Emitted after the details closes and all transitions are complete.
         */
        "onSlAfterHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted after the details opens and all transitions are complete.
         */
        "onSlAfterShow"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the details closes. Calling `event.preventDefault()` will prevent it from being closed.
         */
        "onSlHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the details opens. Calling `event.preventDefault()` will prevent it from being opened.
         */
        "onSlShow"?: (event: CustomEvent<any>) => void;
        /**
          * Indicates whether or not the details is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
        /**
          * The summary to show in the details header. If you need to display HTML, use the `summary` slot instead.
         */
        "summary"?: string;
    }
    interface ADialog {
        /**
          * The dialog's label as displayed in the header. You should always include a relevant label even when using `no-header`, as it is required for proper accessibility.
         */
        "label"?: string;
        /**
          * Set to true to disable the header. This will also remove the default close button, so please ensure you provide an easy, accessible way for users to dismiss the dialog.
         */
        "noHeader"?: boolean;
        /**
          * Emitted after the dialog closes and all transitions are complete.
         */
        "onSlAfterHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted after the dialog opens and all transitions are complete.
         */
        "onSlAfterShow"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the dialog closes. Calling `event.preventDefault()` will prevent it from being closed.
         */
        "onSlHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the overlay is clicked. Calling `event.preventDefault()` will prevent the dialog from closing.
         */
        "onSlOverlayDismiss"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the dialog opens. Calling `event.preventDefault()` will prevent it from being opened.
         */
        "onSlShow"?: (event: CustomEvent<any>) => void;
        /**
          * Indicates whether or not the dialog is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
    }
    interface ADrawer {
        /**
          * By default, the drawer slides out of its containing block (usually the viewport). To make the drawer slide out of its parent element, set this prop and add `position: relative` to the parent.
         */
        "contained"?: boolean;
        /**
          * The drawer's label as displayed in the header. You should always include a relevant label even when using `no-header`, as it is required for proper accessibility.
         */
        "label"?: string;
        /**
          * Removes the header. This will also remove the default close button, so please ensure you provide an easy, accessible way for users to dismiss the drawer.
         */
        "noHeader"?: boolean;
        /**
          * Emitted after the drawer closes and all transitions are complete.
         */
        "onSlAfterHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted after the drawer opens and all transitions are complete.
         */
        "onSlAfterShow"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the drawer closes. Calling `event.preventDefault()` will prevent it from being closed.
         */
        "onSlHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the overlay is clicked. Calling `event.preventDefault()` will prevent the drawer from closing.
         */
        "onSlOverlayDismiss"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the drawer opens. Calling `event.preventDefault()` will prevent it from being opened.
         */
        "onSlShow"?: (event: CustomEvent<any>) => void;
        /**
          * Indicates whether or not the drawer is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
        /**
          * The direction from which the drawer will open.
         */
        "placement"?: 'top' | 'right' | 'bottom' | 'left';
    }
    interface ADropdown {
        /**
          * Determines whether the dropdown should hide when a menu item is selected.
         */
        "closeOnSelect"?: boolean;
        /**
          * The dropdown will close when the user interacts outside of this element (e.g. clicking).
         */
        "containingElement"?: HTMLElement;
        /**
          * The distance in pixels from which to offset the panel away from its trigger.
         */
        "distance"?: number;
        /**
          * Emitted after the dropdown closes and all transitions are complete.
         */
        "onSlAfterHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted after the dropdown opens and all transitions are complete.
         */
        "onSlAfterShow"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the dropdown closes. Calling `event.preventDefault()` will prevent it from being closed.
         */
        "onSlHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the dropdown opens. Calling `event.preventDefault()` will prevent it from being opened.
         */
        "onSlShow"?: (event: CustomEvent<any>) => void;
        /**
          * Indicates whether or not the dropdown is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
        /**
          * The preferred placement of the dropdown panel. Note that the actual placement may vary as needed to keep the panel inside of the viewport.
         */
        "placement"?: | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'left'
    | 'left-start'
    | 'left-end';
        /**
          * The distance in pixels from which to offset the panel along its trigger.
         */
        "skidding"?: number;
    }
    interface AForm {
        /**
          * The first name
         */
        "first"?: string;
        /**
          * The last name
         */
        "last"?: string;
        /**
          * The middle name
         */
        "middle"?: string;
    }
    interface AIcon {
        /**
          * An alternative description to use for accessibility. If omitted, the name or src will be used to generate it.
         */
        "label"?: string;
        /**
          * The name of the icon to draw.
         */
        "name"?: string;
        /**
          * Emitted when the icon failed to load.
         */
        "onAError"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the icon has loaded.
         */
        "onALoad"?: (event: CustomEvent<any>) => void;
        /**
          * An external URL of an SVG file.
         */
        "src"?: string;
    }
    interface AIconButton {
        /**
          * Set to true to disable the button.
         */
        "disabled"?: boolean;
        /**
          * An alternative description to use for accessibility. If omitted, the name or src will be used to generate it.
         */
        "label"?: string;
        /**
          * The name of the icon to draw. See the icon component for a full list of icons.
         */
        "name"?: string;
        /**
          * An external URL of an SVG file.
         */
        "src"?: string;
    }
    interface AInput {
        /**
          * The input's autocaptialize attribute.
         */
        "autocapitalize"?: string;
        /**
          * The input's autocomplete attribute.
         */
        "autocomplete"?: string;
        /**
          * The input's autocorrect attribute.
         */
        "autocorrect"?: string;
        /**
          * The input's autofocus attribute.
         */
        "autofocus"?: boolean;
        /**
          * Set to true to add a clear button when the input is populated.
         */
        "clearable"?: boolean;
        /**
          * Set to true to disable the input.
         */
        "disabled"?: boolean;
        /**
          * The input's inputmode attribute.
         */
        "inputmode"?: | 'none'
    | 'text'
    | 'decimal'
    | 'numeric'
    | 'tel'
    | 'search'
    | 'email'
    | 'url';
        /**
          * Set to true to indicate that the user input is invalid.
         */
        "invalid"?: boolean;
        /**
          * The input's label.
         */
        "label"?: string;
        /**
          * The input's max attribute.
         */
        "max"?: number;
        /**
          * The input's maxlength attribute.
         */
        "maxlength"?: number;
        /**
          * The input's min attribute.
         */
        "min"?: number;
        /**
          * The input's minlength attribute.
         */
        "minlength"?: number;
        /**
          * The input's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onSlBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onSlChange"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onSlFocus"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control receives input.
         */
        "onSlInput"?: (event: CustomEvent<any>) => void;
        /**
          * The input's pattern attribute.
         */
        "pattern"?: string;
        /**
          * Set to true to draw a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Set to true for a readonly input.
         */
        "readonly"?: boolean;
        /**
          * The input's required attribute.
         */
        "required"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The input's step attribute.
         */
        "step"?: number;
        /**
          * Set to true to add a password toggle button for password inputs.
         */
        "togglePassword"?: boolean;
        /**
          * The input's type.
         */
        "type"?: | 'email'
    | 'number'
    | 'password'
    | 'search'
    | 'tel'
    | 'text'
    | 'url';
        /**
          * Set to true to indicate that the user input is valid.
         */
        "valid"?: boolean;
        /**
          * The input's value attribute.
         */
        "value"?: string;
    }
    interface AMenu {
        /**
          * Emitted when the menu loses focus.
         */
        "onSlBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the menu gains focus.
         */
        "onSlFocus"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when a menu item is selected.
         */
        "onSlSelect"?: (event: CustomEvent<any>) => void;
    }
    interface AMenuDivider {
    }
    interface AMenuItem {
        /**
          * Set to true to draw the menu item in an active state.
         */
        "active"?: boolean;
        /**
          * Set to true to draw the item in a checked state.
         */
        "checked"?: boolean;
        /**
          * Set to true to draw the menu item in a disabled state.
         */
        "disabled"?: boolean;
        /**
          * Emitted when the menu item becomes active.
         */
        "onSlActivate"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the menu item becomes inactive.
         */
        "onSlDeactivate"?: (event: CustomEvent<any>) => void;
        /**
          * A unique value to store in the menu item.
         */
        "value"?: string;
    }
    interface AMenuLabel {
    }
    interface AProgressBar {
        /**
          * The progress bar's percentage, 0 to 100.
         */
        "percentage"?: number;
    }
    interface AProgressRing {
        /**
          * The current progress percentage, 0 - 100.
         */
        "percentage"?: number;
        /**
          * The size of the progress ring in pixels.
         */
        "size"?: number;
        /**
          * The stroke width of the progress ring in pixels.
         */
        "strokeWidth"?: number;
    }
    interface ARadio {
        /**
          * Set to true to draw the radio in a checked state.
         */
        "checked"?: boolean;
        /**
          * Set to true to disable the radio.
         */
        "disabled"?: boolean;
        /**
          * The radio's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onSlBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control's checked state changes.
         */
        "onSlChange"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onSlFocus"?: (event: CustomEvent<any>) => void;
        /**
          * The radio's value attribute.
         */
        "value"?: string;
    }
    interface ARange {
        /**
          * Set to true to disable the input.
         */
        "disabled"?: boolean;
        /**
          * The input's max attribute.
         */
        "max"?: number;
        /**
          * The input's min attribute.
         */
        "min"?: number;
        /**
          * The input's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onSlBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onSlChange"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onSlFocus"?: (event: CustomEvent<any>) => void;
        /**
          * The input's step attribute.
         */
        "step"?: number;
        /**
          * The preferred placedment of the tooltip.
         */
        "tooltip"?: 'top' | 'bottom' | 'none';
        /**
          * A function used to format the tooltip's value.
         */
        "tooltipFormatter"?: (value: number) => string;
        /**
          * The input's value attribute.
         */
        "value"?: number;
    }
    interface ARating {
        /**
          * Disables the rating.
         */
        "disabled"?: boolean;
        /**
          * A function that returns the symbols to display. Accepts an option `value` parameter you can use to map a specific symbol to a value.
         */
        "getSymbol"?: (value?: number) => string;
        /**
          * The highest rating to show.
         */
        "max"?: number;
        /**
          * Emitted when the rating's value changes.
         */
        "onSlChange"?: (event: CustomEvent<any>) => void;
        /**
          * The minimum increment value allowed by the control.
         */
        "precision"?: number;
        /**
          * Makes the rating readonly.
         */
        "readonly"?: boolean;
        /**
          * The current rating.
         */
        "value"?: number;
    }
    interface ASelect {
        /**
          * Set to true to disable the select control.
         */
        "disabled"?: boolean;
        /**
          * Set to true to indicate that the user input is invalid.
         */
        "invalid"?: boolean;
        /**
          * The select's label.
         */
        "label"?: string;
        /**
          * The maximum number of tags to show when `multiple` is true. After the maximum, "+n" will be shown to indicate the number of additional items that are selected. Set to -1 to remove the limit.
         */
        "maxTagsVisible"?: number;
        /**
          * Set to true to enable multiselect.
         */
        "multiple"?: boolean;
        /**
          * The select's name.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus
         */
        "onSlBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onSlChange"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control gains focus
         */
        "onSlFocus"?: (event: CustomEvent<any>) => void;
        /**
          * Set to true to draw a pill-style select with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The select's placeholder text.
         */
        "placeholder"?: string;
        /**
          * The select's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Set to true to indicate that the user input is valid.
         */
        "valid"?: boolean;
        /**
          * The value of the control. This will be a string or an array depending on `multiple`.
         */
        "value"?: string | Array<string>;
    }
    interface ASkeleton {
        /**
          * Determines which effect the skeleton will use.
         */
        "effect"?: 'pulse' | 'sheen' | 'none';
    }
    interface ASpinner {
    }
    interface ASwitch {
        /**
          * Set to true to draw the switch in a checked state.
         */
        "checked"?: boolean;
        /**
          * Set to true to disable the switch.
         */
        "disabled"?: boolean;
        /**
          * The switch's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onSlBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control's checked state changes.
         */
        "onSlChange"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onSlFocus"?: (event: CustomEvent<any>) => void;
        /**
          * The switch's value attribute.
         */
        "value"?: string;
    }
    interface ATab {
        /**
          * Set to true to draw the tab in an active state.
         */
        "active"?: boolean;
        /**
          * Set to true to draw the tab in a disabled state.
         */
        "disabled"?: boolean;
        /**
          * The name of the tab panel the tab will control. The panel must be located in the same tab group.
         */
        "panel"?: string;
    }
    interface ATabGroup {
        /**
          * Emitted when a tab is hidden.
         */
        "onSlTabHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when a tab is shown.
         */
        "onSlTabShow"?: (event: CustomEvent<any>) => void;
        /**
          * The placement of the tabs.
         */
        "placement"?: 'top' | 'bottom' | 'left' | 'right';
    }
    interface ATabPanel {
        /**
          * When true, the tab panel will be shown.
         */
        "active"?: boolean;
        /**
          * The tab panel's name.
         */
        "name"?: string;
    }
    interface ATag {
        /**
          * Set to true to make the tag clearable.
         */
        "clearable"?: boolean;
        /**
          * Emitted when the clear button is activated.
         */
        "onSlClear"?: (event: CustomEvent<any>) => void;
        /**
          * Set to true to draw a pill-style tag with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The tag's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The tag's type.
         */
        "type"?: | 'primary'
    | 'success'
    | 'info'
    | 'warning'
    | 'danger'
    | 'text';
    }
    interface ATextarea {
        /**
          * The textarea's autocaptialize attribute.
         */
        "autocapitalize"?: string;
        /**
          * The textarea's autocomplete attribute.
         */
        "autocomplete"?: string;
        /**
          * The textarea's autocorrect attribute.
         */
        "autocorrect"?: string;
        /**
          * The textarea's autofocus attribute.
         */
        "autofocus"?: boolean;
        /**
          * Set to true to disable the textarea.
         */
        "disabled"?: boolean;
        /**
          * The textarea's inputmode attribute.
         */
        "inputmode"?: | 'none'
    | 'text'
    | 'decimal'
    | 'numeric'
    | 'tel'
    | 'search'
    | 'email'
    | 'url';
        /**
          * Set to true to indicate that the user input is invalid.
         */
        "invalid"?: boolean;
        /**
          * The textarea's label.
         */
        "label"?: string;
        /**
          * The textarea's maxlength attribute.
         */
        "maxlength"?: number;
        /**
          * The textarea's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onSlBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onSlChange"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onSlFocus"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control receives input.
         */
        "onSlInput"?: (event: CustomEvent<any>) => void;
        /**
          * The textarea's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Set to true for a readonly textarea.
         */
        "readonly"?: boolean;
        /**
          * The textarea's required attribute.
         */
        "required"?: boolean;
        /**
          * Controls how the textarea can be resized.
         */
        "resize"?: 'none' | 'vertical' | 'auto';
        /**
          * The number of rows to display by default.
         */
        "rows"?: number;
        /**
          * The textarea's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Set to true to indicate that the user input is valid.
         */
        "valid"?: boolean;
        /**
          * The textarea's value attribute.
         */
        "value"?: string;
    }
    interface ATooltip {
        /**
          * The tooltip's content.
         */
        "content"?: string;
        /**
          * Set to true to disable the tooltip so it won't show when triggered.
         */
        "disabled"?: boolean;
        /**
          * The distance in pixels from which to offset the tooltip away from its target.
         */
        "distance"?: number;
        /**
          * Emitted after the tooltip has hidden and all transitions are complete.
         */
        "onSlAfterHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted after the tooltip has shown and all transitions are complete.
         */
        "onSlAfterShow"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the tooltip begins to hide. Calling `event.preventDefault()` will prevent it from being hidden.
         */
        "onSlHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the tooltip begins to show. Calling `event.preventDefault()` will prevent it from being shown.
         */
        "onSlShow"?: (event: CustomEvent<any>) => void;
        /**
          * Indicates whether or not the tooltip is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
        /**
          * The preferred placement of the tooltip. Note that the actual placement may vary as needed to keep the tooltip inside of the viewport.
         */
        "placement"?: | 'top'
    | 'top-start'
    | 'top-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'left'
    | 'left-start'
    | 'left-end';
        /**
          * The distance in pixels from which to offset the tooltip along its target.
         */
        "skidding"?: number;
        /**
          * Controls how the tooltip is activated. Possible options include `click`, `hover`, `focus`, and `manual`. Multiple options can be passed by separating them with a space. When manual is used, the tooltip must be activated programmatically.
         */
        "trigger"?: string;
    }
    interface IntrinsicElements {
        "a-alert": AAlert;
        "a-animation": AAnimation;
        "a-avatar": AAvatar;
        "a-badge": ABadge;
        "a-button": AButton;
        "a-button-group": AButtonGroup;
        "a-card": ACard;
        "a-checkbox": ACheckbox;
        "a-details": ADetails;
        "a-dialog": ADialog;
        "a-drawer": ADrawer;
        "a-dropdown": ADropdown;
        "a-form": AForm;
        "a-icon": AIcon;
        "a-icon-button": AIconButton;
        "a-input": AInput;
        "a-menu": AMenu;
        "a-menu-divider": AMenuDivider;
        "a-menu-item": AMenuItem;
        "a-menu-label": AMenuLabel;
        "a-progress-bar": AProgressBar;
        "a-progress-ring": AProgressRing;
        "a-radio": ARadio;
        "a-range": ARange;
        "a-rating": ARating;
        "a-select": ASelect;
        "a-skeleton": ASkeleton;
        "a-spinner": ASpinner;
        "a-switch": ASwitch;
        "a-tab": ATab;
        "a-tab-group": ATabGroup;
        "a-tab-panel": ATabPanel;
        "a-tag": ATag;
        "a-textarea": ATextarea;
        "a-tooltip": ATooltip;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "a-alert": LocalJSX.AAlert & JSXBase.HTMLAttributes<HTMLAAlertElement>;
            "a-animation": LocalJSX.AAnimation & JSXBase.HTMLAttributes<HTMLAAnimationElement>;
            "a-avatar": LocalJSX.AAvatar & JSXBase.HTMLAttributes<HTMLAAvatarElement>;
            "a-badge": LocalJSX.ABadge & JSXBase.HTMLAttributes<HTMLABadgeElement>;
            "a-button": LocalJSX.AButton & JSXBase.HTMLAttributes<HTMLAButtonElement>;
            "a-button-group": LocalJSX.AButtonGroup & JSXBase.HTMLAttributes<HTMLAButtonGroupElement>;
            "a-card": LocalJSX.ACard & JSXBase.HTMLAttributes<HTMLACardElement>;
            "a-checkbox": LocalJSX.ACheckbox & JSXBase.HTMLAttributes<HTMLACheckboxElement>;
            "a-details": LocalJSX.ADetails & JSXBase.HTMLAttributes<HTMLADetailsElement>;
            "a-dialog": LocalJSX.ADialog & JSXBase.HTMLAttributes<HTMLADialogElement>;
            "a-drawer": LocalJSX.ADrawer & JSXBase.HTMLAttributes<HTMLADrawerElement>;
            "a-dropdown": LocalJSX.ADropdown & JSXBase.HTMLAttributes<HTMLADropdownElement>;
            "a-form": LocalJSX.AForm & JSXBase.HTMLAttributes<HTMLAFormElement>;
            "a-icon": LocalJSX.AIcon & JSXBase.HTMLAttributes<HTMLAIconElement>;
            "a-icon-button": LocalJSX.AIconButton & JSXBase.HTMLAttributes<HTMLAIconButtonElement>;
            "a-input": LocalJSX.AInput & JSXBase.HTMLAttributes<HTMLAInputElement>;
            "a-menu": LocalJSX.AMenu & JSXBase.HTMLAttributes<HTMLAMenuElement>;
            "a-menu-divider": LocalJSX.AMenuDivider & JSXBase.HTMLAttributes<HTMLAMenuDividerElement>;
            "a-menu-item": LocalJSX.AMenuItem & JSXBase.HTMLAttributes<HTMLAMenuItemElement>;
            "a-menu-label": LocalJSX.AMenuLabel & JSXBase.HTMLAttributes<HTMLAMenuLabelElement>;
            "a-progress-bar": LocalJSX.AProgressBar & JSXBase.HTMLAttributes<HTMLAProgressBarElement>;
            "a-progress-ring": LocalJSX.AProgressRing & JSXBase.HTMLAttributes<HTMLAProgressRingElement>;
            "a-radio": LocalJSX.ARadio & JSXBase.HTMLAttributes<HTMLARadioElement>;
            "a-range": LocalJSX.ARange & JSXBase.HTMLAttributes<HTMLARangeElement>;
            "a-rating": LocalJSX.ARating & JSXBase.HTMLAttributes<HTMLARatingElement>;
            "a-select": LocalJSX.ASelect & JSXBase.HTMLAttributes<HTMLASelectElement>;
            "a-skeleton": LocalJSX.ASkeleton & JSXBase.HTMLAttributes<HTMLASkeletonElement>;
            "a-spinner": LocalJSX.ASpinner & JSXBase.HTMLAttributes<HTMLASpinnerElement>;
            "a-switch": LocalJSX.ASwitch & JSXBase.HTMLAttributes<HTMLASwitchElement>;
            "a-tab": LocalJSX.ATab & JSXBase.HTMLAttributes<HTMLATabElement>;
            "a-tab-group": LocalJSX.ATabGroup & JSXBase.HTMLAttributes<HTMLATabGroupElement>;
            "a-tab-panel": LocalJSX.ATabPanel & JSXBase.HTMLAttributes<HTMLATabPanelElement>;
            "a-tag": LocalJSX.ATag & JSXBase.HTMLAttributes<HTMLATagElement>;
            "a-textarea": LocalJSX.ATextarea & JSXBase.HTMLAttributes<HTMLATextareaElement>;
            "a-tooltip": LocalJSX.ATooltip & JSXBase.HTMLAttributes<HTMLATooltipElement>;
        }
    }
}
